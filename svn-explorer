#!/usr/bin/env ruby
# frozen_string_literal: true
require 'readline'

#
# Constants
#
SEPARATOR = '/'
REPO_URL = begin
  # Read command line arguments
  arg = ARGV[0]
  if arg.nil?
    STDERR.puts("usage: #{$PROGRAM_NAME} <repository>")
    exit(1)
  end

  # Handle trailing slashes
  if arg[-1] != SEPARATOR
    arg + SEPARATOR
  else
    arg.sub(/(#{Regexp.escape(SEPARATOR)})+$/, SEPARATOR)
  end
end

#
# Utility functions
#
def url(buffer)
  return REPO_URL + buffer.map { |path| path + SEPARATOR } .join()
end

def error(msg)
  STDERR.puts("#{$PROGRAM_NAME}: #{msg}")
end

#
# Main logic
#
def read(path_stack)
  loop do
    begin
      line = Readline.readline("#{url(path_stack)}$ ", true)
      STDERR.puts if line.nil?
      return line
    rescue Interrupt
      STDERR.puts('^C')
    end
  end
end

def parse(line)
  # TODO: 제대로 파싱하기
  return line.split
end

class EvaluateResult
  def initialize(path_stack, cmd = nil)
    @path_stack = path_stack
    @cmd = cmd
  end

  def path_stack; @path_stack; end
  def cmd; @cmd; end
end
def evaluate(path_stack, program, arguments)
  case program

  # List
  when 'll', 'l'
    # TODO: 파라미터 처리
    # TODO: 좀더 추가적인 정보를 주도록 설정
    system("svn ls '#{url(path_stack)}'")
    return EvaluateResult.new(path_stack)

  when 'ls'
    # TODO: 파라미터 처리
    system("svn ls '#{url(path_stack)}' | column")
    return EvaluateResult.new(path_stack)

  # Change directory
  when 'cd'
    # TODO: '/'로 자르기
    directories = arguments[0].split('/').reject(&:empty?)

    # 인자가 없을경우 루트 디렉토리로 감
    if directories.nil?
      return EvaluateResult.new([])
    end

    path_stack = directories.reduce(path_stack) do |path_stack, dirname|
      # '.', '..' 특수처리
      next path_stack if dirname == '.'
      next path_stack[0...-1] if dirname == '..'

      # 디렉토리 존재하는지 검사
      if not system("svn ls '#{url(path_stack + [dirname])}' --depth empty >/dev/null 2>/dev/null")
        error("The directory '#{dirname}' does not exist")
        break path_stack
      end

      # TODO: 디렉토리가 맞는지 검사

      # 디렉토리 변경
      path_stack + [dirname]
    end

    return EvaluateResult.new(path_stack)
  when /^\.+$/
    count = program.length - 1
    return EvaluateResult.new(path_stack[0...-count])

  # Exit commands
  when 'exit', 'quit'
    return EvaluateResult.new(path_stack, :exit)

  # Command not found
  else
    error("command not found: #{program}")
    return EvaluateResult.new(path_stack)
  end
end

path_stack = []
Readline.completion_append_character = ''
Readline.completion_proc = -> query {
  # TODO: 깊은 디렉토리 탐색도 지원해야함
  `svn ls '#{url(path_stack)}'`.lines.map(&:chomp).grep(/^#{Regexp.escape(query)}/)
}
while line = read(path_stack)
  tokens = parse(line)
  next if tokens.empty?

  result = evaluate(path_stack, tokens[0], tokens[1..-1])

  path_stack = result.path_stack
  break if result.cmd == :exit
end
