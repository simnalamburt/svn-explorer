#!/usr/bin/env ruby
# frozen_string_literal: true
require 'readline'

#
# Constants
#
SEPARATOR = '/'
PATH_BUFFER = []
REPO_URL = begin
  arg = ARGV[0]
  if arg.nil?
    STDERR.puts("usage: #{$PROGRAM_NAME} <repository>")
    exit(1)
  end

  # Handle trailing slashes
  if arg[-1] != SEPARATOR
    arg + SEPARATOR
  else
    arg.sub(/(#{SEPARATOR})+$/, SEPARATOR)
  end
end

#
# Utility functions
#
def url(buffer)
  return REPO_URL + buffer.map { |path| path + SEPARATOR } .join()
end

def error(msg)
  STDERR.puts("#{$PROGRAM_NAME}: #{msg}")
end

#
# Main logic
#
Readline.completion_append_character = ''
Readline.completion_proc = -> query {
  # TODO: 깊은 디렉토리 탐색도 지원해야함
  `svn ls '#{url(PATH_BUFFER)}'`.lines.map(&:chomp).grep(/^#{Regexp.escape(query)}/)
}

loop do
  line = begin
    Readline.readline("#{url(PATH_BUFFER)}$ ", true)
  rescue Interrupt
    STDERR.puts('^C')
    next
  end

  # Handle Ctrl+D
  # TODO: 패턴매칭으로 잡기
  if line.nil?
    STDERR.puts
    break
  end

  argv = line.split
  case argv[0]

  # List
  when 'll', 'l'
    # TODO: 좀더 추가적인 정보를 주도록 설정
    system("svn ls '#{url(PATH_BUFFER)}'")
  when 'ls'
    system("svn ls '#{url(PATH_BUFFER)}' | column")

  # Change directory
  when 'cd'
    # TODO: '/'로 자르기
    dirname = argv[1]

    # 인자가 없을경우 루트 디렉토리로 감
    if dirname.nil?
      PATH_BUFFER.clear()
      next
    end

    # '..' 특수처리
    if dirname == '..'
      PATH_BUFFER.pop()
      next
    end

    # 디렉토리 존재하는지 검사
    if not system("svn ls '#{url(PATH_BUFFER + [dirname])}' --depth empty >/dev/null 2>/dev/null")
      error("The directory '#{dirname}' does not exist")
      next
    end

    # TODO: 디렉토리가 맞는지 검사

    PATH_BUFFER.push(dirname)
  when /^\.+$/
    PATH_BUFFER.pop(argv[0].length - 1)

  # Exit commands
  when 'exit'
    break

  # Empty line, do nothing
  when nil
    next

  # Command not found
  else
    error("command not found: #{argv[0]}")
  end
end
